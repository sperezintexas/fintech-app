# myInvestments Environment Variables
# Copy this file to .env.local and fill in your values
# NEVER commit .env.local or any file with real credentials!

# MongoDB Connection
# For local development with Docker: mongodb://localhost:27017/myinvestments
# For MongoDB Atlas: mongodb+srv://user:password@cluster.mongodb.net/myinvestments
MONGODB_URI=mongodb://localhost:27017/myinvestments

# If MONGODB_URI has special chars (# ! $ etc) that get mangled in your host, use base64:
# echo -n "mongodb+srv://user:pass@host/?appName=SmartTrader" | base64
# MONGODB_URI_B64=<base64-string>

# Data Cleanup (optional) - purge when nearing storage limit
# MONGODB_STORAGE_LIMIT_MB=512     # Atlas free tier 512MB (default). Use 512000 for 500GB
# MONGODB_PURGE_THRESHOLD=0.75     # Purge when at 75% of limit (default 0.75)

# X Auth – Auth.js v5 (Sign in with X only; not used for CI/Slack)
# Generate secret: npx auth secret
AUTH_SECRET=your_auth_secret_here
# Debug auth (X OAuth, callbacks): set AUTH_DEBUG=true and restart; logs [auth] to console
# AUTH_DEBUG=true
# Local dev only: set SKIP_AUTH=true to bypass X sign-in
# SKIP_AUTH=true
# Job runner roles: local node = slave (schedules only); remote node = master (runs jobs).
# Next.js (local/dev): leave AGENDA_MASTER unset — slave, no job execution.
# Smart-scheduler (remote/prod): set AGENDA_MASTER=true — master, only process that runs jobs.
# AGENDA_MASTER=true
# Optional: JOB_RUNNER=false skips starting the scheduler (e.g. local pm2 with only web).
# JOB_RUNNER=false
# Backend scheduler (Kotlin): set on backend only. NEXTJS_URL=http://localhost:3000 (or http://app:3000 in Docker).
# CRON_SECRET=shared_secret  # Optional; if set, POST /api/internal/run-task requires Authorization: Bearer <CRON_SECRET> (backend uses this to trigger jobs).
# Production: set NEXTAUTH_URL to your app URL (e.g. AWS App Runner)
NEXTAUTH_URL=http://localhost:3000
# Access key (optional): bootstrap key for sign-in when X fails. Sign in with this key once, then create keys in app (Settings → Access keys) and remove this.
# ACCESS_KEY_SEED=your_one_time_bootstrap_key

# X OAuth – Sign in with X (same app as posting)
# Portal: https://developer.x.com/ → your app → User authentication → OAuth 2.0
# X callback URLs – add both in the X Developer Portal (User authentication → OAuth 2.0):
#   Local:      http://localhost:3000/api/auth/callback/twitter
#   Production: https://your-app.awsapprunner.com/api/auth/callback/twitter
# After changing callback URL, regenerate keys in the portal and paste new values below (and in App Runner / .env.prod).
X_CLIENT_ID=your_x_client_id
X_CLIENT_SECRET=your_x_client_secret

# X posting (alerts; test: pnpm run test:x-post-cli). Login uses X_CLIENT_ID / X_CLIENT_SECRET above (OAuth 2.0).
# Posting uses OAuth 1.0a: same app, but different keys. In portal → your app → Keys and tokens:
#   Bearer (read-only) → X_BEARER_TOKEN
#   Consumer (app) → X_CONSUMER_KEY, X_CONSUMER_SECRET (API Key + API Key Secret)
#   User (for posting) → X_ACCESS_TOKEN, X_ACCESS_TOKEN_SECRET (generate under Authentication Tokens, Read and write)
X_BEARER_TOKEN=
X_CONSUMER_KEY=
X_CONSUMER_SECRET=
X_ACCESS_TOKEN=
X_ACCESS_TOKEN_SECRET=
# Optional: X_POST_AS_USERNAME=AtxBogart

# CI build status → Slack (GitHub Actions secret SLACK_WEBHOOK_URL), not X

# xAI Grok API (Smart Grok Chat)
XAI_API_KEY=your_xai_api_key_here

# Web Search (Smart Grok - weather, news, general queries)
# SerpAPI key from https://serpapi.com/
WEB_SEARCH_API_KEY=your_serpapi_key_here

# Optional: Upstash Redis for rate limiting (multi-instance). When set, API rate limits use Redis instead of in-memory.
# Get from https://console.upstash.com/ (create Redis database, copy REST URL and token).
# UPSTASH_REDIS_REST_URL=https://xxx.upstash.io
# UPSTASH_REDIS_REST_TOKEN=your_token
# Optional: Redis can also be used for session store (Auth.js) or hot price cache; configure separately if needed.
# Optional: CORS allowed origin (e.g. https://app.example.com). When set, API responses include Access-Control-Allow-Origin.
# CORS_ORIGIN=
