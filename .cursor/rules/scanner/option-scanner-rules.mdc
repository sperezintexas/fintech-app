---
description: Guidelines for evolving OptionScanner to hybrid rule-based + Grok-powered reasoning
globs:
alwaysApply: false
---
# OptionScanner Hybrid Grok Integration Guidelines

## Architecture Decision
Prefer **hybrid** approach:
- Stage 1: fast, deterministic, zero-cost rule-based filter (existing logic)
- Stage 2: Grok API only for promising / edge / high-P/L / low-DTE positions

## Core Flow
1. Run existing fastRuleBasedScan() → get preliminary flags & metrics
2. Filter candidates (configurable thresholds: |P/L| > 12%, DTE < 14, IV > 55, etc.)
3. For each candidate → call Grok with structured prompt containing:
   - Position details (type, strike, exp, qty, cost basis)
   - Current market data (underlying price, option price, IV, delta, theta)
   - Preliminary suggestion
   - Account context (risk profile, strategy goals)
4. Grok returns: { recommendation: 'HOLD'|'BUY_TO_CLOSE', confidence: 0-1, explanation: string }
5. Store both preliminary + final in alerts/recommendations

## Prompt Style (in src/lib/xai-grok.ts or dedicated prompt file)
"You are a conservative options trading advisor. Given this position and current market data, decide whether to HOLD or BUY_TO_CLOSE. Be concise, risk-aware, explain reasoning step-by-step. Output JSON only."

## Cost & Performance Guardrails
- Max parallel Grok calls: 5–8 (avoid API overload)
- Cache recent market data (30–60 min)
- Fallback: if Grok fails/rate-limited → use preliminary recommendation + "Grok unavailable" note
- Log token usage per scan

## File Targets
- src/lib/option-scanner.ts           ← add hybrid logic, candidate filter, grok stage
- src/lib/xai-grok.ts                 ← add specialized callOptionDecision() helper
- src/types/portfolio.ts              ← extend with source: 'rules' | 'grok'

Start by extracting fastRuleBasedScan() as pure function if not already done, then add the Grok stage.
