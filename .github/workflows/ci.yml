name: CI

# Monorepo: apps/frontend (Next.js, pnpm workspace), apps/backend (Kotlin/Spring). Frontend build produces apps/frontend/.next; Docker builds from root.
# Deploy (App Runner) runs only on main when ENABLE_AWS_DEPLOY=true.
on:
  push:
  pull_request:

env:
  NODE_VERSION: "22"
  JAVA_VERSION: "21"

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4.2.2

      - name: Setup pnpm
        uses: pnpm/action-setup@v4.2.0

      - name: Setup Node.js
        uses: actions/setup-node@v4.2.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run ESLint
        run: pnpm run lint

  typecheck:
    name: Type Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4.2.2

      - name: Setup pnpm
        uses: pnpm/action-setup@v4.2.0

      - name: Setup Node.js
        uses: actions/setup-node@v4.2.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run TypeScript compiler
        run: pnpm run typecheck

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4.2.2

      - name: Setup pnpm
        uses: pnpm/action-setup@v4.2.0

      - name: Setup Node.js
        uses: actions/setup-node@v4.2.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run tests
        run: pnpm test

  backend:
    name: Backend (Kotlin)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4.2.2

      - name: Set up JDK
        uses: actions/setup-java@v4.2.0
        with:
          distribution: "temurin"
          java-version: ${{ env.JAVA_VERSION }}
          cache: "gradle"

      - name: Build backend
        run: cd apps/backend && ./gradlew build -x test --no-daemon

  build:
    name: Build (frontend)
    runs-on: ubuntu-latest
    needs: [lint, typecheck, test]
    steps:
      - name: Checkout
        uses: actions/checkout@v4.2.2

      - name: Setup pnpm
        uses: pnpm/action-setup@v4.2.0

      - name: Setup Node.js
        uses: actions/setup-node@v4.2.0
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Cache Next.js build
        uses: actions/cache@v4.2.0
        with:
          path: apps/frontend/.next/cache
          key: next-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('apps/frontend/**/*.ts', 'apps/frontend/**/*.tsx', 'apps/frontend/**/*.js', 'apps/frontend/**/*.jsx') }}
          restore-keys: |
            next-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}-
      - name: Build application
        run: pnpm run build
        env:
          MONGODB_URI: mongodb://localhost:27017
          MONGODB_DB: myinvestments
          NODE_OPTIONS: --max-old-space-size=4096

      - name: List build output
        id: list
        run: |
          cd "$GITHUB_WORKSPACE"
          if [ -d apps/frontend/.next ]; then
            echo "Build output: apps/frontend/.next exists"
            ls -la apps/frontend/.next
            echo "has_next=true" >> $GITHUB_OUTPUT
          else
            echo "::error::.next not found after build. Check the Build application step for errors (e.g. OOM, Next.js failure)."
            echo "has_next=false" >> $GITHUB_OUTPUT
          fi

      - name: Fail if build did not produce .next
        if: steps.list.outputs.has_next != 'true'
        run: |
          echo "Build did not produce .next. Deployment requires a successful Next.js build."
          exit 1

      - name: Upload build artifacts
        if: steps.list.outputs.has_next == 'true'
        uses: actions/upload-artifact@v4.4.0
        with:
          name: build
          path: apps/frontend/.next
          include-hidden-files: true
          if-no-files-found: error
          retention-days: 7

  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Checkout
        uses: actions/checkout@v4.2.2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: myinvestments:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            MONGODB_URI=mongodb://localhost:27017
            MONGODB_DB=myinvestments

  # AWS App Runner: build image, push to ECR, start-deployment only. Runs only on push to main (not on develop or PRs).
  # Config updates: run scripts/update-apprunner-env.sh manually. Variables: ENABLE_AWS_DEPLOY=true, APP_RUNNER_SERVICE_ARN. Secrets: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY.
  apprunner-deploy:
    name: Build & Deploy to App Runner
    runs-on: ubuntu-latest
    needs: [lint, typecheck, test, build, docker, backend]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && vars.ENABLE_AWS_DEPLOY == 'true'
    env:
      AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
      APP_NAME: myinvestments
    steps:
      - name: Checkout
        uses: actions/checkout@v4.2.2

      - name: Validate AWS deploy inputs
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          SERVICE_ARN: ${{ vars.APP_RUNNER_SERVICE_ARN }}
        run: |
          if [ -z "$AWS_ACCESS_KEY_ID" ] || [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
            echo "::error::AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY secrets must be set."
            exit 1
          fi
          if [ -z "$SERVICE_ARN" ]; then
            echo "::error::APP_RUNNER_SERVICE_ARN variable not set. Add it in Settings → Actions → Variables."
            exit 1
          fi
          case "$SERVICE_ARN" in
            arn:aws:apprunner:*)
              ;;
            *)
              echo "::error::APP_RUNNER_SERVICE_ARN must be a valid App Runner service ARN (arn:aws:apprunner:...)."
              exit 1
              ;;
          esac
          echo "Inputs validated."

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repository (if not exists)
        run: |
          aws ecr describe-repositories --repository-names ${{ env.APP_NAME }} --region ${{ env.AWS_REGION }} 2>/dev/null || \
          aws ecr create-repository --repository-name ${{ env.APP_NAME }} --region ${{ env.AWS_REGION }}

      - name: Build and push Docker image (linux/amd64 for App Runner)
        id: build-push
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}:${{ github.sha }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.APP_NAME }}:latest
          build-args: |
            MONGODB_URI=placeholder
            MONGODB_DB=myinvestments
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify ECR image is amd64
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ARCH=$(aws ecr describe-images \
            --repository-name ${{ env.APP_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --image-ids imageTag=$IMAGE_TAG \
            --query 'imageDetails[0].imageManifestMediaType' --output text 2>/dev/null || true)
          DIGEST=$(aws ecr describe-images \
            --repository-name ${{ env.APP_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --image-ids imageTag=$IMAGE_TAG \
            --query 'imageDetails[0].imageDigest' --output text)
          if [ -z "$DIGEST" ] || [ "$DIGEST" = "None" ]; then
            echo "::error::Image ${{ env.APP_NAME }}:$IMAGE_TAG not found in ECR."
            exit 1
          fi
          echo "Image $ECR_REGISTRY/${{ env.APP_NAME }}:$IMAGE_TAG present (digest=$DIGEST). Built with platforms: linux/amd64 for App Runner."

      - name: Deploy to App Runner
        id: deploy
        env:
          SERVICE_ARN: ${{ vars.APP_RUNNER_SERVICE_ARN }}
        run: |
          SVC_STATUS=$(aws apprunner describe-service --service-arn "$SERVICE_ARN" --region ${{ env.AWS_REGION }} --query 'Service.Status' --output text 2>/dev/null || echo "UNKNOWN")
          if [ "$SVC_STATUS" != "RUNNING" ]; then
            echo "::error::App Runner service is not RUNNING (current: $SVC_STATUS). Start deployment only works when the service is RUNNING."
            echo "In AWS Console → App Runner → your service: fix any errors (e.g. CREATE_FAILED, bad image), resume if paused, then re-run this workflow."
            exit 1
          fi
          OP_ID=$(aws apprunner start-deployment --service-arn "$SERVICE_ARN" --region ${{ env.AWS_REGION }} --query 'OperationId' --output text)
          echo "operation_id=$OP_ID" >> $GITHUB_OUTPUT
          echo "Deployment started (operation $OP_ID); waiting for completion..."

      - name: Wait for App Runner deployment
        env:
          SERVICE_ARN: ${{ vars.APP_RUNNER_SERVICE_ARN }}
          OPERATION_ID: ${{ steps.deploy.outputs.operation_id }}
        run: |
          MAX_ATTEMPTS=45
          SLEEP_SEC=10
          for i in $(seq 1 $MAX_ATTEMPTS); do
            STATUS=$(aws apprunner list-operations --service-arn "$SERVICE_ARN" --region ${{ env.AWS_REGION }} --query "OperationSummaryList[?Id=='$OPERATION_ID'].Status | [0]" --output text 2>/dev/null || echo "UNKNOWN")
            [ -z "$STATUS" ] || [ "$STATUS" = "None" ] && STATUS="PENDING"
            case "$STATUS" in
              SUCCEEDED)
                echo "Deployment succeeded."
                exit 0
                ;;
              FAILED|ROLLBACK_SUCCEEDED)
                echo "::error::Deployment failed or rolled back: $STATUS"
                exit 1
                ;;
              *)
                echo "Waiting for deployment... ($i/$MAX_ATTEMPTS) operation_status=$STATUS"
                [ $i -eq $MAX_ATTEMPTS ] && { echo "::error::Deployment did not complete within $((MAX_ATTEMPTS * SLEEP_SEC / 60)) minutes."; exit 1; }
                sleep $SLEEP_SEC
                ;;
            esac
          done
          exit 1

      - name: Get service URL
        id: url
        env:
          APP_URL_VAR: ${{ vars.APP_URL }}
          SERVICE_ARN: ${{ vars.APP_RUNNER_SERVICE_ARN }}
        run: |
          if [ -n "$APP_URL_VAR" ]; then
            echo "url=$APP_URL_VAR" >> $GITHUB_OUTPUT
          else
            SVC_URL=$(aws apprunner describe-service --service-arn "$SERVICE_ARN" --region ${{ env.AWS_REGION }} --query 'Service.ServiceUrl' --output text)
            echo "url=https://$SVC_URL" >> $GITHUB_OUTPUT
          fi

      - name: Verify App Runner deployment (health check)
        id: health
        env:
          APP_URL: ${{ steps.url.outputs.url }}
        run: |
          if [ -z "$APP_URL" ]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
            exit 0
          fi
          case "$APP_URL" in http://*|https://*) ;; *) APP_URL="https://$APP_URL";; esac
          BASE="${APP_URL%/}"
          HEALTH_URL="${BASE}/api/health/live"
          for i in 1 2 3 4 5 6; do
            RES=$(curl -sSf -w "\n%{http_code}" --connect-timeout 10 --max-time 15 "$HEALTH_URL" 2>/dev/null || true)
            CODE=$(echo "$RES" | tail -n 1)
            BODY=$(echo "$RES" | head -n -1)
            if [ "$CODE" = "200" ]; then
              RAW=$(echo "$BODY" | jq -r '.status // "unknown"')
              case "$(echo "$RAW" | tr '[:upper:]' '[:lower:]')" in
                ok|degraded|healthy|success) echo "status=ok" >> $GITHUB_OUTPUT; echo "version=$(echo "$BODY" | jq -r '.version // ""')" >> $GITHUB_OUTPUT; exit 0 ;;
              esac
            fi
            [ $i -lt 6 ] && sleep 10
          done
          echo "status=error" >> $GITHUB_OUTPUT
          echo "version=" >> $GITHUB_OUTPUT
          echo "Health check failed after 6 attempts (10s apart)"
          exit 1

      - name: Validate health before Slack
        run: |
          STATUS="${{ steps.health.outputs.status }}"
          if [ -z "$STATUS" ] || [ "$STATUS" = "skipped" ]; then
            echo "Health check did not run or was skipped; cannot report success. Set APP_URL or ensure App Runner service is reachable."
            exit 1
          fi
          if [ "$STATUS" != "ok" ]; then
            echo "Health check did not pass (status=$STATUS); deployment is not healthy."
            exit 1
          fi
          echo "Health check passed; posting to Slack."

      - name: Notify Slack (App Runner deploy)
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DEPLOY_RESULT: ${{ job.status }}
          HEALTH_STATUS: ${{ steps.health.outputs.status }}
          HEALTH_VERSION: ${{ steps.health.outputs.version }}
          APP_URL: ${{ steps.url.outputs.url }}
          RUN_URL: ${{ format('https://github.com/{0}/actions/runs/{1}', github.repository, github.run_id) }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not set; skipping App Runner deploy Slack notification."
            exit 0
          fi
          if [ "$DEPLOY_RESULT" = "success" ]; then
            EMOJI=":white_check_mark:"
            COLOR="good"
            TITLE="App Runner Deploy: Success"
          else
            EMOJI=":x:"
            COLOR="danger"
            TITLE="App Runner Deploy: Failed"
          fi
          COMMIT_ONE=$(echo "$COMMIT_MSG" | head -n 1 | tr -d '\n' | sed 's/"/\\"/g')
          PAYLOAD=$(jq -n \
            --arg color "$COLOR" \
            --arg title "$EMOJI $TITLE" \
            --arg fallback "App Runner Deploy $DEPLOY_RESULT" \
            --arg commit "${{ github.sha }}" \
            --arg msg "${COMMIT_ONE:-n/a}" \
            --arg health "${HEALTH_STATUS:-n/a}" \
            --arg version "${HEALTH_VERSION:-n/a}" \
            --arg url "${APP_URL:-n/a}" \
            --arg run_url "$RUN_URL" \
            '{
              attachments: [{
                color: $color,
                title: $title,
                fallback: $fallback,
                fields: [
                  { title: "Commit", value: $commit, short: true },
                  { title: "Message", value: $msg, short: false },
                  { title: "Health", value: $health, short: true },
                  { title: "Version", value: $version, short: true },
                  { title: "URL", value: $url, short: false },
                  { title: "Workflow", value: ("<" + $run_url + "|View run>"), short: false }
                ]
              }]
            }')
          curl -sSf -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$SLACK_WEBHOOK_URL" || true

  # Post build: notify Slack with build status; runs after core pipeline (no dependency on apprunner-deploy so it always runs).
  # Set repository secret SLACK_WEBHOOK_URL to your Slack Incoming Webhook URL to receive notifications.
  # Variables: APP_URL (optional, for health check on main/develop).
  notify-slack:
    name: Notify Slack
    runs-on: ubuntu-latest
    needs: [lint, typecheck, test, build, docker, backend]
    if: always() && !cancelled()
    steps:
      - name: Verify deployment (health check)
        id: health
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
        env:
          APP_URL: ${{ vars.APP_URL }}
        run: |
          if [ -z "$APP_URL" ]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
            echo "APP_URL not set; skipping health check (set APP_URL to your App Runner URL)."
            exit 0
          fi
          case "$APP_URL" in http://*|https://*) ;; *) APP_URL="https://$APP_URL";; esac
          BASE="${APP_URL%/}"
          HEALTH_URL="${BASE}/api/health/live"
          RES=$(curl -sSf -w "\n%{http_code}" "$HEALTH_URL" || true)
          BODY=$(echo "$RES" | head -n -1)
          CODE=$(echo "$RES" | tail -n 1)
          if [ "$CODE" = "200" ]; then
            RAW=$(echo "$BODY" | jq -r '.status // "unknown"')
            case "$(echo "$RAW" | tr '[:upper:]' '[:lower:]')" in
              ok|degraded|healthy|success) STATUS="ok" ;;
              *) STATUS="$RAW" ;;
            esac
            VERSION=$(echo "$BODY" | jq -r '.version // ""')
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          else
            STATUS="error"
            echo "version=" >> $GITHUB_OUTPUT
          fi
          echo "status=$STATUS" >> $GITHUB_OUTPUT

      - name: Validate health (fail if deployment unhealthy)
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') && steps.health.outputs.status != '' && steps.health.outputs.status != 'skipped'
        run: |
          case "$(echo "${{ steps.health.outputs.status }}" | tr '[:upper:]' '[:lower:]')" in
            ok) exit 0 ;;
            *) echo "Deployment health check failed: ${{ steps.health.outputs.status }}"; exit 1 ;;
          esac

      - name: Send Slack build notification
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          STATUS: ${{ (needs.lint.result == 'failure' || needs.typecheck.result == 'failure' || needs.test.result == 'failure' || needs.build.result == 'failure' || needs.docker.result == 'failure' || needs.backend.result == 'failure') && 'failure' || (needs.lint.result == 'cancelled' || needs.typecheck.result == 'cancelled' || needs.test.result == 'cancelled' || needs.build.result == 'cancelled' || needs.docker.result == 'cancelled' || needs.backend.result == 'cancelled') && 'cancelled' || 'success' }}
          RUN_URL: ${{ format('https://github.com/{0}/actions/runs/{1}', github.repository, github.run_id) }}
          BRANCH: ${{ github.ref_name }}
          COMMIT: ${{ github.sha }}
          COMMIT_MSG: ${{ github.event.head_commit.message || github.event.pull_request.title || github.ref_name }}
          ACTOR: ${{ github.actor }}
          HEALTH_STATUS: ${{ steps.health.outputs.status }}
          HEALTH_VERSION: ${{ steps.health.outputs.version }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "::warning::SLACK_WEBHOOK_URL secret not found. To enable Slack notifications:"
            echo "  1. Go to GitHub repo Settings → Secrets and variables → Actions → Secrets"
            echo "  2. Create a repository secret named exactly: SLACK_WEBHOOK_URL"
            echo "  3. Paste your Slack Incoming Webhook URL as the value"
            echo "Skipping Slack notification."
            exit 0
          fi
          COMMIT_MSG_ONE=$(echo "$COMMIT_MSG" | head -n 1 | tr -d '\n')
          if [ "$STATUS" = "success" ]; then
            EMOJI=":white_check_mark:"
            COLOR="good"
            TEXT="CI passed"
          elif [ "$STATUS" = "cancelled" ]; then
            EMOJI=":warning:"
            COLOR="warning"
            TEXT="CI cancelled"
          else
            EMOJI=":x:"
            COLOR="danger"
            TEXT="CI failed"
          fi
          PAYLOAD=$(jq -n \
            --arg color "$COLOR" \
            --arg fallback "$EMOJI $TEXT — $BRANCH" \
            --arg title "$EMOJI Build $TEXT" \
            --arg run_url "$RUN_URL" \
            --arg branch "$BRANCH" \
            --arg actor "$ACTOR" \
            --arg commit "$COMMIT" \
            --arg commit_msg "$COMMIT_MSG_ONE" \
            --arg health_status "${HEALTH_STATUS:-}" \
            --arg health_version "${HEALTH_VERSION:-}" \
            '{
              attachments: [{
                color: $color,
                fallback: $fallback,
                title: $title,
                title_link: $run_url,
                fields: (
                  [
                    { title: "Branch", value: $branch, short: true },
                    { title: "Author", value: $actor, short: true },
                    { title: "Commit ID", value: $commit, short: false },
                    { title: "Commit", value: $commit_msg, short: false }
                  ]
                  + (if $health_status != "" and $health_status != "skipped" then [{ title: "Health", value: $health_status, short: true }] else [] end)
                  + (if $health_version != "" then [{ title: "Version", value: $health_version, short: true }] else [] end)
                )
              }]
            }')
          curl -sSf -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$SLACK_WEBHOOK_URL" || true
