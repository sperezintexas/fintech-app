name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  NODE_VERSION: "22"

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Run ESLint
        run: npm run lint

  typecheck:
    name: Type Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Run TypeScript compiler
        run: npx tsc --noEmit

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Run tests
        run: npm test

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint, typecheck, test]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Cache Next.js build
        uses: actions/cache@v4
        with:
          path: .next/cache
          key: next-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.ts', '**/*.tsx', '**/*.js', '**/*.jsx') }}
          restore-keys: |
            next-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-

      - name: Build application
        run: npm run build
        env:
          MONGODB_URI: mongodb://localhost:27017
          MONGODB_DB: myinvestments
          NODE_OPTIONS: --max-old-space-size=4096

      - name: List build output
        id: list
        run: |
          cd "$GITHUB_WORKSPACE"
          if [ -d .next ]; then
            echo "Build output: .next exists"
            ls -la .next
            echo "has_next=true" >> $GITHUB_OUTPUT
          else
            echo "::error::.next not found after build. Check the Build application step for errors (e.g. OOM, Next.js failure)."
            echo "has_next=false" >> $GITHUB_OUTPUT
          fi

      - name: Fail if build did not produce .next
        if: steps.list.outputs.has_next != 'true'
        run: |
          echo "Build did not produce .next. Deployment requires a successful Next.js build."
          exit 1

      - name: Upload build artifacts
        if: steps.list.outputs.has_next == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: build
          path: .next
          include-hidden-files: true
          if-no-files-found: error
          retention-days: 7

  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: myinvestments:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            MONGODB_URI=mongodb://localhost:27017
            MONGODB_DB=myinvestments

  # AWS: build Docker image, push to ECR, deploy to Elastic Beanstalk (main only, when enabled).
  # Set variable ENABLE_AWS_DEPLOY=true and secrets AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY to run.
  aws-deploy:
    name: Build & Deploy to AWS (EB)
    runs-on: ubuntu-latest
    needs: [lint, typecheck, test, build, docker]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && vars.ENABLE_AWS_DEPLOY == 'true'
    env:
      AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
      APP_NAME: myinvestments
      EB_ENV_NAME: ${{ vars.EB_ENV_NAME || 'myinvestments-prod' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repository (if not exists)
        run: |
          aws ecr describe-repositories --repository-names ${{ env.APP_NAME }} --region ${{ env.AWS_REGION }} 2>/dev/null || \
          aws ecr create-repository --repository-name ${{ env.APP_NAME }} --region ${{ env.AWS_REGION }}

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build \
            --build-arg MONGODB_URI=placeholder \
            --build-arg MONGODB_DB=myinvestments \
            -t $ECR_REGISTRY/${{ env.APP_NAME }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.APP_NAME }}:latest \
            .
          docker push $ECR_REGISTRY/${{ env.APP_NAME }}:$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.APP_NAME }}:latest

      - name: Update Dockerrun.aws.json
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          cat > Dockerrun.aws.json << EOF
          {
            "AWSEBDockerrunVersion": "1",
            "Image": {
              "Name": "$ECR_REGISTRY/${{ env.APP_NAME }}:latest",
              "Update": "true"
            },
            "Ports": [
              { "ContainerPort": 3000, "HostPort": 3000 }
            ],
            "Logging": "/var/log/nodejs"
          }
          EOF
          cat Dockerrun.aws.json

      - name: Create deployment package
        run: |
          zip -r deploy.zip . \
            -x "*.git*" \
            -x "node_modules/*" \
            -x ".next/*" \
            -x "tests/*" \
            -x "docs/*" \
            -x "docker-compose.yml"

      - name: Deploy to Elastic Beanstalk
        uses: einaregilsson/beanstalk-deploy@v22
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: ${{ env.APP_NAME }}
          environment_name: ${{ env.EB_ENV_NAME }}
          version_label: ${{ github.sha }}
          region: ${{ env.AWS_REGION }}
          deployment_package: deploy.zip
          wait_for_environment_recovery: 120

      - name: Get deployment URL
        id: url
        env:
          APP_URL_VAR: ${{ vars.APP_URL }}
        run: |
          if [ -n "$APP_URL_VAR" ]; then
            echo "url=$APP_URL_VAR" >> $GITHUB_OUTPUT
          else
            CNAME=$(aws elasticbeanstalk describe-environments --environment-names ${{ env.EB_ENV_NAME }} --region ${{ env.AWS_REGION }} --query 'Environments[0].CNAME' --output text)
            echo "url=http://$CNAME" >> $GITHUB_OUTPUT
          fi

      - name: Verify AWS deployment (health check)
        id: health
        env:
          APP_URL: ${{ steps.url.outputs.url }}
        run: |
          if [ -z "$APP_URL" ]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
            exit 0
          fi
          case "$APP_URL" in http://*|https://*) ;; *) APP_URL="https://$APP_URL";; esac
          BASE="${APP_URL%/}"
          HEALTH_URL="${BASE}/api/health"
          for i in 1 2 3 4 5 6; do
            RES=$(curl -sSf -w "\n%{http_code}" --connect-timeout 10 --max-time 15 "$HEALTH_URL" 2>/dev/null || true)
            CODE=$(echo "$RES" | tail -n 1)
            BODY=$(echo "$RES" | head -n -1)
            if [ "$CODE" = "200" ]; then
              RAW=$(echo "$BODY" | jq -r '.status // "unknown"')
              case "$(echo "$RAW" | tr '[:upper:]' '[:lower:]')" in
                ok|degraded|healthy|success) echo "status=ok" >> $GITHUB_OUTPUT; echo "version=$(echo "$BODY" | jq -r '.version // ""')" >> $GITHUB_OUTPUT; exit 0 ;;
              esac
            fi
            [ $i -lt 6 ] && sleep 10
          done
          echo "status=error" >> $GITHUB_OUTPUT
          echo "version=" >> $GITHUB_OUTPUT
          echo "Health check failed after 6 attempts (10s apart)"
          exit 1

      - name: Notify Slack (AWS deploy)
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          DEPLOY_RESULT: ${{ job.status }}
          HEALTH_STATUS: ${{ steps.health.outputs.status }}
          HEALTH_VERSION: ${{ steps.health.outputs.version }}
          APP_URL: ${{ steps.url.outputs.url }}
          RUN_URL: ${{ format('https://github.com/{0}/actions/runs/{1}', github.repository, github.run_id) }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not set; skipping AWS deploy Slack notification."
            exit 0
          fi
          if [ "$DEPLOY_RESULT" = "success" ]; then
            EMOJI=":white_check_mark:"
            COLOR="good"
            TITLE="AWS EB Deploy: Success"
          else
            EMOJI=":x:"
            COLOR="danger"
            TITLE="AWS EB Deploy: Failed"
          fi
          COMMIT_ONE=$(echo "$COMMIT_MSG" | head -n 1 | tr -d '\n' | sed 's/"/\\"/g')
          PAYLOAD=$(jq -n \
            --arg color "$COLOR" \
            --arg title "$EMOJI $TITLE" \
            --arg fallback "AWS EB Deploy $DEPLOY_RESULT" \
            --arg commit "${{ github.sha }}" \
            --arg msg "${COMMIT_ONE:-n/a}" \
            --arg health "${HEALTH_STATUS:-n/a}" \
            --arg version "${HEALTH_VERSION:-n/a}" \
            --arg url "${APP_URL:-n/a}" \
            --arg run_url "$RUN_URL" \
            '{
              attachments: [{
                color: $color,
                title: $title,
                fallback: $fallback,
                fields: [
                  { title: "Commit", value: $commit, short: true },
                  { title: "Message", value: $msg, short: false },
                  { title: "Health", value: $health, short: true },
                  { title: "Version", value: $version, short: true },
                  { title: "URL", value: $url, short: false },
                  { title: "Workflow", value: ("<" + $run_url + "|View run>"), short: false }
                ]
              }]
            }')
          curl -sSf -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$SLACK_WEBHOOK_URL" || true

  # Post build: optional Vercel deployment status; verify deployment via app health check (APP_URL = AWS EB or Vercel).
  # Notify Slack with commit, deployment status, health result, app version.
  # Secrets: SLACK_WEBHOOK_URL; optional VERCEL_TOKEN. Vars: APP_URL (health check URL, e.g. EB or Vercel).
  notify-slack:
    name: Notify Slack
    runs-on: ubuntu-latest
    needs: [lint, typecheck, test, build, docker]
    if: always() && !cancelled()
    steps:
      - name: Get deployment status (optional Vercel)
        id: vercel
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ vars.VERCEL_PROJECT_ID }}
          VERCEL_ORG_ID: ${{ vars.VERCEL_ORG_ID }}
        run: |
          if [ -z "$VERCEL_TOKEN" ] || [ -z "$VERCEL_PROJECT_ID" ]; then
            echo "state=skipped" >> $GITHUB_OUTPUT
            echo "url=" >> $GITHUB_OUTPUT
            echo "Vercel token or project id not set; skipping optional deployment status."
            exit 0
          fi
          QUERY="projectId=$VERCEL_PROJECT_ID"
          [ -n "$VERCEL_ORG_ID" ] && QUERY="${QUERY}&teamId=${VERCEL_ORG_ID}"
          RES=$(curl -sSf -H "Authorization: Bearer $VERCEL_TOKEN" "https://api.vercel.com/v6/deployments?${QUERY}&limit=1")
          STATE=$(echo "$RES" | jq -r '.deployments[0].state // "unknown"')
          DEPLOY_URL=$(echo "$RES" | jq -r '.deployments[0].url // ""')
          echo "state=$STATE" >> $GITHUB_OUTPUT
          echo "url=$DEPLOY_URL" >> $GITHUB_OUTPUT

      - name: Verify deployment (health check)
        id: health
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
        env:
          APP_URL: ${{ vars.APP_URL || steps.vercel.outputs.url }}
        run: |
          if [ -z "$APP_URL" ]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
            echo "APP_URL not set; skipping health check (set APP_URL to your EB or Vercel URL)."
            exit 0
          fi
          case "$APP_URL" in http://*|https://*) ;; *) APP_URL="https://$APP_URL";; esac
          BASE="${APP_URL%/}"
          HEALTH_URL="${BASE}/api/health"
          RES=$(curl -sSf -w "\n%{http_code}" "$HEALTH_URL" || true)
          BODY=$(echo "$RES" | head -n -1)
          CODE=$(echo "$RES" | tail -n 1)
          if [ "$CODE" = "200" ]; then
            RAW=$(echo "$BODY" | jq -r '.status // "unknown"')
            case "$(echo "$RAW" | tr '[:upper:]' '[:lower:]')" in
              ok|degraded|healthy|success) STATUS="ok" ;;
              *) STATUS="$RAW" ;;
            esac
            VERSION=$(echo "$BODY" | jq -r '.version // ""')
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          else
            STATUS="error"
            echo "version=" >> $GITHUB_OUTPUT
          fi
          echo "status=$STATUS" >> $GITHUB_OUTPUT

      - name: Validate health (fail if deployment unhealthy)
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') && steps.health.outputs.status != '' && steps.health.outputs.status != 'skipped'
        run: |
          case "$(echo "${{ steps.health.outputs.status }}" | tr '[:upper:]' '[:lower:]')" in
            ok) exit 0 ;;
            *) echo "Deployment health check failed: ${{ steps.health.outputs.status }}"; exit 1 ;;
          esac

      - name: Send Slack build notification
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          STATUS: ${{ (needs.lint.result == 'failure' || needs.typecheck.result == 'failure' || needs.test.result == 'failure' || needs.build.result == 'failure' || needs.docker.result == 'failure') && 'failure' || (needs.lint.result == 'cancelled' || needs.typecheck.result == 'cancelled' || needs.test.result == 'cancelled' || needs.build.result == 'cancelled' || needs.docker.result == 'cancelled') && 'cancelled' || 'success' }}
          RUN_URL: ${{ format('https://github.com/{0}/actions/runs/{1}', github.repository, github.run_id) }}
          BRANCH: ${{ github.ref_name }}
          COMMIT: ${{ github.sha }}
          COMMIT_MSG: ${{ github.event.head_commit.message || github.event.pull_request.title || github.ref_name }}
          ACTOR: ${{ github.actor }}
          VERCEL_STATE: ${{ steps.vercel.outputs.state }}
          VERCEL_URL: ${{ steps.vercel.outputs.url }}
          HEALTH_STATUS: ${{ steps.health.outputs.status }}
          HEALTH_VERSION: ${{ steps.health.outputs.version }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "::warning::SLACK_WEBHOOK_URL secret not found. To enable Slack notifications:"
            echo "  1. Go to GitHub repo Settings → Secrets and variables → Actions → Secrets"
            echo "  2. Create a repository secret named exactly: SLACK_WEBHOOK_URL"
            echo "  3. Paste your Slack Incoming Webhook URL as the value"
            echo "Skipping Slack notification."
            exit 0
          fi
          COMMIT_MSG_ONE=$(echo "$COMMIT_MSG" | head -n 1 | tr -d '\n')
          if [ "$STATUS" = "success" ]; then
            EMOJI=":white_check_mark:"
            COLOR="good"
            TEXT="CI passed"
          elif [ "$STATUS" = "cancelled" ]; then
            EMOJI=":warning:"
            COLOR="warning"
            TEXT="CI cancelled"
          else
            EMOJI=":x:"
            COLOR="danger"
            TEXT="CI failed"
          fi
          PAYLOAD=$(jq -n \
            --arg color "$COLOR" \
            --arg fallback "$EMOJI $TEXT — $BRANCH" \
            --arg title "$EMOJI Build $TEXT" \
            --arg run_url "$RUN_URL" \
            --arg branch "$BRANCH" \
            --arg actor "$ACTOR" \
            --arg commit "$COMMIT" \
            --arg commit_msg "$COMMIT_MSG_ONE" \
            --arg vercel_state "${VERCEL_STATE:-}" \
            --arg vercel_url "${VERCEL_URL:-}" \
            --arg health_status "${HEALTH_STATUS:-}" \
            --arg health_version "${HEALTH_VERSION:-}" \
            '{
              attachments: [{
                color: $color,
                fallback: $fallback,
                title: $title,
                title_link: $run_url,
                fields: (
                  [
                    { title: "Branch", value: $branch, short: true },
                    { title: "Author", value: $actor, short: true },
                    { title: "Commit ID", value: $commit, short: false },
                    { title: "Commit", value: $commit_msg, short: false }
                  ]
                  + (if $vercel_state != "" and $vercel_state != "skipped" then [{ title: "Vercel", value: $vercel_state, short: true }, (if $vercel_url != "" then { title: "Deploy URL", value: $vercel_url, short: true } else null end)] | map(select(. != null)) else [] end)
                  + (if $health_status != "" and $health_status != "skipped" then [{ title: "Health", value: $health_status, short: true }] else [] end)
                  + (if $health_version != "" then [{ title: "Version", value: $health_version, short: true }] else [] end)
                )
              }]
            }')
          curl -sSf -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$SLACK_WEBHOOK_URL" || true
